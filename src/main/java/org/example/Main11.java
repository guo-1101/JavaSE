package org.example;

public class Main11 {
    public static void main(String[] args) {

//        反射
//        反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，
//        对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。
//
//        可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！
//
//        Java类加载机制
//        在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的：
//
//        在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，
//        在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），
//        注意此Class对象只会存在一个，与加载的类唯一对应！
//
//        默认情况下（仅使用默认类加载器）每个类都有且只有一个唯一的Class对象存放在JVM中，我们无论通过什么方式访问，都是始终是那一个对象。
//        Class对象中包含我们类的一些信息，包括类里面有哪些方法、哪些变量等等。
//
//        Class类详解
//        通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，
//        来获取类的信息和操作类。

//        注解

//        @Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。

//        注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，
//        就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。

//        元注解
//        元注解是作用于注解上的注解，用于我们编写自定义的注解：
//        @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。
//        @Documented - 标记这些注解是否包含在用户文档中。
//        @Target - 标记这个注解应该是哪种 Java 成员。
//        @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)
//        @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。
//        看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看@Override是如何定义的

//        该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。
//        @Retention表示此注解的保留策略，包括三种策略，而这里定义为只在代码中。
//        一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。

//        注解的使用
//        我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。
//        注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型

//        默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入
//        我们也可以使用default关键字来为这些属性指定默认值
//        当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组
    }
//        定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上
    @Tests(value = "",test = "",values = {"value1", "value2"})
    public void aa(){
    }
}
