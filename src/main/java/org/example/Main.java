package org.example;

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world!");

//        《C语言程序设计》《数据结构》《操作系统》《计算机组成原理》

//        二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。
//        比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，
//        在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了）


//        C语言虽然支持按照我们更容易理解的方式去进行编程，但是最后还是会编译成汇编指令最后变成计算机可以直接执行的指令，
//        不过具体的编译过程，我们不需要再关心了，我们只需要去写就可以了，而对我们代码进行编译的东西，称为编译器。

//        代码-->编译成汇编语言-->变成机器指令-->CPU干活

//        前面我们介绍了C语言，它实际上就是通过编译，将我们可以看懂的代码，翻译为计算机能够直接执行的指令，
//        这样计算机就可以按照我们想要的方式去进行计算了。当然，除了C语言之外，也有其他的语言，比如近几年也很火的Python，
//        它跟C语言不同，它并不会先进行编译，而是直接交给解释器解释执行

//        代码--直接输入到-->Python解释器--解释执行-->CPU干活

//        编程语言就分为两大类：
//        编译型语言：需要先编译为计算机可以直接执行的命令才可以运行。优点是计算机直接运行，性能高；缺点是与平台密切相关，
//        在一种操作系统上编译的程序，无法在其他非同类操作系统上运行，比如Windows下的exe程序在Mac上就无法运行。
//        解释型语言：只需要通过解释器代为执行即可，不需要进行编译。
//        优点是可以跨平台，因为解释是解释器的事情，只需要在各个平台上安装对应的解释器，代码不需要任何修改就可以直接运行；
//        缺点是需要依靠解释器解释执行，效率肯定没直接编译成机器指令运行的快，并且会产生额外的资源占用。

//        Java语言：一次编写，到处运行，它旨在打破平台的限制，让Java语言可以运行在任何平台上，并且不需要重新编译，实现跨平台运行。

//        代码--编译-->.class二进制文件-->二进制文件计算机并不能直接运行，而是需要交给JVM（Java虚拟机）执行。-->CPU干活

//        JVM是个什么东西呢？简单来说，它就像我们前面介绍的解释器一样。
//        由于Java又需要编译同时还需要依靠JVM解释执行，所以说Java既是编译型语言，也是解释型语言。

//        JRE（Java Runtime Environment）：Java的运行环境，安装了运行环境之后，Java程序才可以运行，
//        一般不做开发，只是需要运行Java程序直接按照JRE即可。
//        JDK（Java Development Kit）：包含JRE，并且还附带了大量开发者工具，我们学习Java程序开发就使用JDK即可。


//        在路径直接输入cmd就可以打开cmd
//        java -version查看Java版本
//        javac Main.java编译文件，编译成.class二进制文件
//        java Main(java com/test/Main) JVM运行.class文件

//        双击Shift打开搜索，什么都可以搜
//        新UI
//        输入registry，打开注册表，勾选ide.experimental.ui


//        一基础

//        变量常量

//        要声明一个变量，我们需要使用以下格式：
//        [数据类型] [变量名称];
//        常量的值只有第一次赋值可以修改，其他任何情况下都不行：
//        final int a = 666;   //在变量前面添加final关键字，表示这是一个常量
//        a = 777;    //常量的值不允许发生修改

//        整数类形

//        在Java中，整数类型包括以下几个：
//        byte 字节型 （8个bit，也就是1个字节）
//        short 短整形（16个bit，也就是2个字节）
//        int 整形（32个bit，也就是4个字节）
//        long 长整形（64个bit，也就是8个字节）
//        隐式类型转换
//        因为都可以表示整数，所以说我们可以将小的整数类型值传递给大的整数类型，反之会出现报错。
        short a = 10;
        int b = a;   //小的类型可以直接传递给表示范围更大的类型
        System.out.println(b);
//        如果需要将其表示为一个long类型的常量数字，那么需要在后面添加大写或是小写的L才可以。
        long c = 922337203685477580L;

//        浮点类型

//        首先来看看Java中的小数类型包含哪些：
//        float 单精度浮点型 （32bit，4字节）
//        double 双精度浮点型（64bit，8字节）
//        同样的，我们可以给常量后面添加大写或小写的F来表示这是一个float类型的常量值
        float d = 9.9F;
//        隐式类型转换为double值
        float e = 9.9F;
        double f = e;
        System.out.println(f);

//        隐式类型转换规则：byte→short(char)→int→long→float→double

//        字符类型

//        char 字符型（16个bit，也就是2字节，它不带符号）
//        字符常量值需要使用单引号囊括，并且内部只能有一个字符
        char g = 'A';

//        布尔类型

//        值只能是true或false
        boolean h = true;

//        String类型，这种类型并不是基本数据类型，它是对象类型

//        取模操作

//        比如我们查看某个数是否为双数，只需要将其对2进行取模操作即可，因为如果是双数一定是可以整除的，如果是单数一定会余1
//        还可以 i % 10 获取个位数 i % 100 获取十位数
        int i = 10;
        System.out.println(i % 2);

//        强制类型转换

//        在括号中填写上强制转换的类型，就可以强制转换到对应的类型了
        int j = 10;
        short k = (short) j;
//        让两个整数计算出小数的结果
//        int a = 8, b = 5;
//        double c = a/(double)b;

//        int b = a++;   //先出结果，再自增
//        int b = ++a;   //先自增，再出结果

        int aa = 8;
        aa = aa + 4;
//        加号和等号连在一起，与a = a + 4效果完全一样    不止加法，包括我们前面介绍的全部算术运算符，都是支持这种缩写的
        aa += 4;

//        &&     与运算，要求两边同时为true才能返回true
//        ||     或运算，要求两边至少要有一个为true才能返回true
//        !      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转

//        三元运算符

//        判断语句 ? 结果1 : 结果2
        int bb = 10;
        char cc = bb > 10 ? 'A' : 'B';   //三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值

//        优先级	运算符	结合性
//        1	( )	从左向右
//        2	- + (强制类型转换) ++ -- 从右向左
//        3	* / % 从左向右
//        4	+(加法，包括字符串) -(减法) 从左向右
//        5	> < >= >= 从左向右
//        6	== != 从左向右
//        7	&& 从左向右
//        8	|| 从左向右
//        9	? : 从右向左
//        10 = += -= *= /= %= 从右向左


//        代码块（花括号）
//        我们可以在花括号中编写一句又一句的代码，实际上这些被大括号囊括起来的内容，我们就称为块（代码块），一个代码块中可以包含多行代码。
//        作用域

//        switch可以精准匹配某个值，但是它不能进行范围判断！！

//        支持使用break和continue
//        switch (目标) {   //我们需要传入一个目标，比如变量，或是计算表达式等
//            case 匹配值:    //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码
//                代码...
//                break;    //代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码
//            case: ...
//            default:
//                其他情况下执行的代码
//        }

//        关键字
//        使用continue关键字来跳过本轮循环，直接开启下一轮。
//        使用break关键字来提前终止整个循环

//        支持使用break和continue
        for (int x = 0; x < 3; x++) {
            if(x == 1) break;
            System.out.println("当前i的值为："+x);
        }

//        我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记
        outer: for (int n = 1; n < 4; ++n) {   //在循环语句前，添加 标签: 来进行标记
            inner: for (int m = 1; m < 4; ++m) {
                if(n == m) break outer;    //break后紧跟要结束的循环标记，当i == j时终止外层循环
                System.out.println(n+", "+m);
            }
        }

//        支持使用break和continue
        int y = 100;
        while (y > 0) {
            if(y < 10) break;
            System.out.println(y);
            y /= 2;
        }

//        可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到do-while语句
        int z = 0;   //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确
        do {  //无论满不满足循环条件，先执行循环体里面的内容
            System.out.println("Hello World!");
            z++;
        } while (z < 10);   //再做判断，如果判断成功，开启下一轮循环，否则结束

    }
}