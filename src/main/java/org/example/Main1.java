package org.example;

//import static org.example.Person1.test1;    //静态导入test方法

public class Main1 {
    public static void main(String[] args) {

//        二类与对象

//        所谓类，就是对一类事物的描述，是抽象的、概念上的定义（人类）
//        对象是某一类事物实际存在的每个个体，因而也被称为实例（每个人个体）


//        创建一个实例对象
//        new 类名();
        new Person1();    //我们可以使用new关键字来创建某个类的对象，注意new后面需要跟上 类名()

//        我们同样可以使用一个变量来指代某个对象，只不过引用类型的变量，存储的是对象的引用，而不是对象本身
        Person1 p = new Person1();    //这里的p存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象


        Person1 p1 = new Person1();
        Person1 p2 = p1;
        System.out.println(p1 == p2);    //使用 == 可以判断两个变量引用的是不是同一个对象
        Person1 p3 = new Person1();    //这两个变量分别引用的是不同的两个对象
        System.out.println(p1 == p3);   //如果两个变量存放的是不同对象的引用，那么肯定就是不一样的了

//        实际上我们之前使用的String类型，也是一个引用类型。而类使用的都是引用类型。

//        注意：方法定义时编写的参数，我们一般称为形式参数，而调用方法实际传入的参数，我们成为实际参数。
//        10  实际参数
        p.test(10);

//        方法的重载
//        注意，如果仅仅是返回值的不同，是不支持重载的！！
//        一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！
        System.out.println(p.sum(10, 20));    //这里可以正常计算两个整数的和
        System.out.println(p.sum(1.5, 2.2));   //当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用

//        构造方法（构造器）
//        构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法
//        这里的new Person1()其实就是在调用无参构造方法！！
        Person1 p4 = new Person1();
        Person1 p5 = new Person1("小明", 18, "男");   //调用自己定义的带三个参数的构造方法
        System.out.println(p5.name);

//        成员变量最先初始化，然后代码块初始化，最后构造方法初始化

//        静态变量和静态方法

//        成员属性：成员变量、成员方法、构造方法，对象所具有的东西，只有某个具体的对象，才能够去使用

//        静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。
//        我们通过使用static关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，
//        操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。
        Person1 p6 = new Person1();
        Person1 p7 = new Person1();
        p6.info = "你干嘛";
        System.out.println(p7.info);   //可以看到，由于静态属性是属于类的，因此无论通过什么方式改变，都改变的是同一个目标
//        一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用
        Person1.info = "让我看看";
        System.out.println(Person1.info);
//        静态方法同样是属于类的，而不是具体的某个对象
        Person1.test();

//        因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值
//        成员变量是某个具体对象拥有的属性，就像小明这个具体的人的名字才叫小明，而静态方法是类具有的，并不是具体对象的，肯定是没办法访问到的。
//        同样的，在静态方法中，无法使用this关键字，因为this关键字代表的是当前的对象本身。
//        但是静态方法是可以访问到静态变量的

//        静态变量，是在什么时候进行初始化的呢？
//        1.访问类的静态变量，或者为静态变量赋值
//        2.new 创建类的实例（隐式加载）
//        3.调用类的静态方法
//        4.子类初始化时

//        所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。

//        静态内容初始化之后，成员变量、代码块、构造方法才初始化。当然，如果我们压根就没有去使用这个类，那么也不会被初始化了。


//        所以说Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限

//        private - 私有，当前类
//        什么都不写 - 默认，同一个包下的类
//        protected - 受保护，不同包下的子类
//        public - 公共，允许在任何地方被访问。

//        静态导入
//        如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以
//        test1();    //直接使用就可以，就像在这个类定义的方法一样



























    }
}
