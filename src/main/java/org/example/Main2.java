package org.example;

public class Main2 {
    public static void main(String[] args) {

//        三封装、继承和多态 抽象类 接口

//        封装、继承和多态是面向对象编程的三大特性。
//        封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。
//        继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。
//        多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。

//        类的封装
//        封装的目的是为了保证变量的安全性，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，
//        可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。
        Person2 person2 = new Person2("小明", 18, "男");
        System.out.println(person2.getName());    //只能通过调用getName()方法来获取名字
//        也就是说，外部现在只能通过调用我定义的方法来获取成员属性

//        可以将构造方法改成私有的，需要通过我们的内部的方式来构造对象
        Person2 person = Person2.getInstance();


//        类的继承
//        1.想要继承一个类，我们只需要使用extends关键字即可
//        2.类的继承可以不断向下，但是同时只能继承一个类，同时，标记为final的类不允许被继承
//        3.当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，
//        除非父类中将属性的访问权限修改为private，那么子类将无法访问（但是依然是继承了这个属性的）
//        4.同样的，在父类中定义的方法同样会被子类继承
//        Student22 student22 = new Student22();
//        student22.study();    //子类不仅有自己的独特技能
//        student22.hello();    //还继承了父类的全部技能

//        5.如果父类存在一个有参构造方法，子类必须在构造方法中调用
//        因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，
//        只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么我们就需要手动指定了
//        既然现在父类需要三个参数才能构造，那么子类需要按照同样的方式调用父类的构造方法

//        使用super代表父类（超类），父类的构造方法就是super()

//        6.我们在使用子类时，可以将其当做父类来使用
        Person22 person22 = new Student22("小明", 18, "男");    //这里使用父类类型的变量，去引用一个子类对象（向上转型）
        person22.hello();    //父类对象的引用相当于当做父类来使用，只能访问父类对象的内容
//        虽然我们这里使用的是父类类型引用的对象，但是这并不代表子类就彻底变成父类了，这里仅仅只是当做父类使用而已。
//        我们也可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类
        Student22 student22 = (Student22) person22;   //使用强制类型转换（向下转型）
        student22.study();
//        这种方式只适用于这个对象本身就是对应的子类才可以，如果本身都不是这个子类，或者说就是父类，那么会出现问题

//        判断一下某个变量所引用的对象到底是什么类
        if(person22 instanceof Student22) {   //我们可以使用instanceof关键字来对类型进行判断
            System.out.println("对象是 Student 类型的");
        }
//        如果变量所引用的对象是对应类型或是对应类型的子类，那么instanceof都会返回true，否则返回false。

//        子类是可以定义和父类同名的属性的
//        在子类存在同名变量的情况下，怎么去访问父类的呢？我们同样可以使用super关键字来表示父类
//        但是注意，没有super.super这种用法


//        方法的重写
//        1.方法的重写不同于之前的方法重载，方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现
        Person22 p1 = new Person22("小明", 18, "男");
        Person22 p2 = new Person22("小明", 18, "男");
        System.out.println(p1.equals(p2));   //此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象
//        只要对象（new Person22）重写了  就还是使用重写后的方法
        Object p11 = new Person22("小明", 18, "男");
        Object p22 = new Person22("小明", 18, "男");
        System.out.println(p11.equals(p22));

//        有时候为了方便查看对象的各个属性，我们可以将Object类提供的toString方法重写了
//        这样，我们直接打印对象时，就会打印出对象的各个属性值了
        System.out.println(p1);

//        2.子类重写方法的访问权限必须高于或等于父类的方法（访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性）
//        3.注意，静态方法不支持重写，因为它是属于类本身的，但是它可以被继承

//        以对象（new Student22）为主！！
        Person22 p = new Student22("小明", 18, "男");
        p.test();
//        这其实就是面向对象编程中多态特性的一种体现。

//        4.注意，我们如果不希望子类重写某个方法，我们可以在方法前添加final关键字，表示这个方法已经是最终形态
//        final + 类 不可以继承
//        final + 成员变量（属性） 不可以重新赋值（有初始值或者构造的时候赋一次值）
//        final + 方法 不可以重写

//        5.如果父类中方法的可见性为private，那么子类同样无法访问，也就不能重写，但是可以定义同名方法
//        并不是对父类方法的重写，仅仅是子类自己创建的一个新方法。
//        6.我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用super关键字


//        抽象类
//        1.public abstract class Person {   //通过添加abstract关键字，表示这个类是一个抽象类
//            public abstract void exam();   //抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体
//        }
//        2.而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法
//        3.抽象类由于不是具体的类定义（它是类的抽象）可能会存在某些方法没有实现，因此无法直接通过new关键字来直接创建对象
//        4.要使用抽象类，我们只能去创建它的子类对象。
//        5.抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类
//        6.如果抽象类的子类也是抽象类，那么可以不用实现父类中的抽象方法
//        7.抽象类中并不是只能有抽象方法，抽象类中也可以有正常方法的实现
//        8.注意，抽象方法的访问权限不能为private


//        接口
//        1.只包含方法的定义
//        2.接口不同于继承，接口可以同时实现多个（个接口的实现使用逗号隔开）
//        3.接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用
        Study222 study222 = new Student222();
//        接口同样支持向下转型
//        4.接口中可以存在方法的默认实现
        study222.test();
//        5.接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法，在接口中定义的变量只能是
//        跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容
//        6.接口是可以继承自其他接口的
//        public interface A exetnds B {
//        }
//        并且接口没有继承数量限制，接口支持多继承
//        public interface A exetnds B, C, D {
//        }


//        枚举类
//        但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。
//        这显然是不够严谨的，有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们预先定义好的状态
        Student2222 student2222 =  new Student2222();
        student2222.setStatus(Status2222.RUNNING);
        System.out.println(student2222.getStatus());
//        枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，
//        我们定义的每一个状态其实就是一个public static final的Status类型成员变量

//        这里使用javap命令对class文件进行反编译得到 Compiled from "Status.java"
//        javap Status2222.class

//        构造方法变了，定义枚举常量也需要跟着变
//        既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法
        student2222.setStatus(Status2222.RUNNING);
        System.out.println(student2222.getStatus().getName());
        System.out.println(student2222.getStatus().name());


    }
}
